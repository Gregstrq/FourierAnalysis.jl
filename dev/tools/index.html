<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tools · FourierAnalysis</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../"><img class="logo" src="../assets/logo.png" alt="FourierAnalysis logo"/></a><h1>FourierAnalysis</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">FourierAnalysis Documentation</a></li><li><a class="toctext" href="../MainModule/">Main Module</a></li><li><a class="toctext" href="../tapers/">Tapering Window</a></li><li><span class="toctext">frequency domain</span><ul><li><a class="toctext" href="../spectra/">Spectral Estimations</a></li><li><a class="toctext" href="../crossspectra/">Cross-Spectral Matrices</a></li><li><a class="toctext" href="../coherence/">Coherence Matrices</a></li><li><a class="toctext" href="../goertzel/">Goertzel&#39;s Algorithms</a></li></ul></li><li><span class="toctext">time-frequency(TF) domain</span><ul><li><a class="toctext" href="../timefrequency/">TF Representations</a></li><li><a class="toctext" href="../timefrequencyuni/">TF Univariate Measures</a></li><li><a class="toctext" href="../timefrequencybi/">TF Bivariate Measures </a></li></ul></li><li><span class="toctext">utilities</span><ul><li><a class="toctext" href="../plots/">Plots</a></li><li class="current"><a class="toctext" href>Tools</a><ul class="internal"><li><a class="toctext" href="#functions-1">functions</a></li><li><a class="toctext" href="#specific-methods-1">specific methods</a></li><li><a class="toctext" href="#generic-methods-1">generic methods</a></li></ul></li><li><a class="toctext" href="../fftw/">FFTW planners</a></li><li><a class="toctext" href="../filters/">Filter Banks</a></li><li><a class="toctext" href="../hilbert/">Hilbert Transform</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>utilities</li><li><a href>Tools</a></li></ul><a class="edit-page" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/master/docs/src/tools.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tools</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="tools.jl-1" href="#tools.jl-1">tools.jl</a></h1><p>This unit implements</p><ul><li><a href="#functions-1">functions</a> that are useful when employing the FFT,</li><li><a href="#specific-methods-1">specific methods</a>: they apply to Julia&#39;s types or to single objects created by <em>FourierAnalysis</em>,</li><li><a href="#generic-methods-1">generic methods</a>: they apply to entire categories of objects created by <em>FourierAnalysis</em>.</li></ul><h2><a class="nav-anchor" id="functions-1" href="#functions-1">functions</a></h2><table><tr><th style="text-align: left">function</th><th style="text-align: left">description</th></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.sinusoidal"><code>sinusoidal</code></a></td><td style="text-align: left">generate a sinusoidal wave</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.fres"><code>fres</code></a></td><td style="text-align: left">FFT frequency resolution</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.f2b"><code>f2b</code></a></td><td style="text-align: left">bin on a real-FFT vector best matching a frequency</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.b2f"><code>b2f</code></a></td><td style="text-align: left">frequency (in Hz) that correspond to a bin on a real-FFT vector</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.fdf"><code>fdf</code></a></td><td style="text-align: left">all Fourier discrete frequencies for a real-FFT</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.brange"><code>brange</code></a></td><td style="text-align: left">range of bins for a real-FFT vector covering all Fourier discrete frequencies</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.bbands"><code>bbands</code></a></td><td style="text-align: left">limits of all bandwidht-spaced band-pass regions of a real-FFT vectors, in bins</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.fbands"><code>fbands</code></a></td><td style="text-align: left">limits of all bandwidht-spaced band-pass regions of a real-FFT vectors, in frequencies (Hz)</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.dB"><code>dB</code></a></td><td style="text-align: left">convert a measure or a ratio between two measures into deciBels</td></tr></table><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FourierAnalysis.sinusoidal" href="#FourierAnalysis.sinusoidal"><code>FourierAnalysis.sinusoidal</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function sinusoidal(a :: IntOrReal,
                    f :: IntOrReal,
                   sr :: Int,
                    t :: Int,
                    θ :: IntOrReal = 0.;
                DClevel = 0.)</code></pre><p>Generate a sinusoidal wave with peak amplitude <code>a</code>, frequency <code>f</code>, sampling rate <code>sr</code>, duration (in samples) <code>t</code>, angle <code>θ</code> (θ=0 makes a sine, θ=π/2 makes a cosine) and optional keyword argument <code>DC</code> (float), the DC level defaulting to zero. It is adopted the convention that a sine wave starts at zero.</p><p><strong>See</strong>: <a href="../MainModule/#IntOrReal-1">IntOrReal</a></p><p><strong>Examples</strong>:</p><pre><code class="language-none">using FourierAnalysis, Plots

# create and plot a sinusoidal wave of 128 samples with
# peak amplitude 1, frequency 12Hz, sr=64, phase=π/2
v=sinusoidal(1., 12, 64, 128, π/2)
plot(v)

# estimate amplitude of a sinusoidal wave using Goertzel algorithm
f, sr, t = 32, 128, 128
v=sinusoidal(3., f, sr, t, 0)
c=goertzel(v, f, sr, t) # c should be equal to 0+3.0im</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/27fb14de7d3fd949536bb04a5d414211c6878e30/src/tools.jl#L15-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FourierAnalysis.fres" href="#FourierAnalysis.fres"><code>FourierAnalysis.fres</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function fres(sr :: Int,
              wl :: Int)</code></pre><p>FFT <strong>f</strong>requency <strong>res</strong>olution given sampling rate <code>sr</code> and window length <code>wl</code>.</p><p><strong>See also</strong>: <a href="#FourierAnalysis.f2b"><code>f2b</code></a>, <a href="#FourierAnalysis.b2f"><code>b2f</code></a>, <a href="#FourierAnalysis.fdf"><code>fdf</code></a>, <a href="#FourierAnalysis.brange"><code>brange</code></a>.</p><p><strong>Examples</strong>:</p><pre><code class="language-none">using FourierAnalysis
fres(1024, 2048) # return 0.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/27fb14de7d3fd949536bb04a5d414211c6878e30/src/tools.jl#L60-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FourierAnalysis.f2b" href="#FourierAnalysis.f2b"><code>FourierAnalysis.f2b</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function f2b(f :: IntOrReal,
            sr :: Int,
            wl :: Int;
        DC :: Bool = false)</code></pre><p><strong>f</strong>requency <strong>to b</strong>in. Return the bin (position) in a real-FFT vector best matching a frequency <code>f</code> (in Hz), given sampling rate <code>sr</code> and window length <code>wl</code>. The frequency can be given either as an integer or as a real number.</p><p>If the requested <code>f</code> is exactly in between two Fourier discrete frequencies, then the smallest of the two equidistant frequancies is returned.</p><p>The FFT vector is assumed to be 1-based (as always in Julia). If <code>DC</code> is false, the first discrete frequency is assumed to be at bin 1, otherwise the DC is assumed to be at bin 1 and the first discrete frequency at bin 2.</p><p>If <code>DC</code> is false return 0 for frequencies inferior to half the frequency resolution.</p><p><strong>See</strong>: <a href="../MainModule/#IntOrReal-1">IntOrReal</a>.</p><p><strong>See also</strong>: <a href="#FourierAnalysis.fres"><code>fres</code></a>, <a href="#FourierAnalysis.b2f"><code>b2f</code></a>, <a href="#FourierAnalysis.fdf"><code>fdf</code></a>, <a href="#FourierAnalysis.brange"><code>brange</code></a>.</p><p><strong>Examples</strong>:</p><pre><code class="language-none">using FourierAnalysis
f2b(10, 512, 1024) # return 20</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/27fb14de7d3fd949536bb04a5d414211c6878e30/src/tools.jl#L80-L112">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FourierAnalysis.b2f" href="#FourierAnalysis.b2f"><code>FourierAnalysis.b2f</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function b2f(bin :: Int,
              sr :: Int,
              wl :: Int;
        DC :: Bool = false)</code></pre><p><strong>b</strong>in <strong>to f</strong>requency. Return the closest discrete Fourier frequency (in Hz) that corresponds to a bin (position) in a real-FFT vector, given sampling rate <code>sr</code> and window length <code>wl</code>. The FFT vector is assumed to be 1-based, as always in Julia.</p><p>If <code>DC</code> is false, the first discrete frequency is assumed to be at bin 1, otherwise the DC level is assumed to be at bin 1 and the first discrete frequency at bin 2.</p><p><strong>See also</strong>: <a href="#FourierAnalysis.f2b"><code>f2b</code></a>, <a href="#FourierAnalysis.fres"><code>fres</code></a>, <a href="#FourierAnalysis.fdf"><code>fdf</code></a>, <a href="#FourierAnalysis.brange"><code>brange</code></a>.</p><p><strong>Examples</strong>:</p><pre><code class="language-none">using FourierAnalysis
f2b(20, 512, 1024) # return 40
f2b(10, 128, 128) # return 10</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/27fb14de7d3fd949536bb04a5d414211c6878e30/src/tools.jl#L123-L148">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FourierAnalysis.fdf" href="#FourierAnalysis.fdf"><code>FourierAnalysis.fdf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function fdf(sr :: Int,
             wl :: Int;
          DC :: Bool = false)</code></pre><p>Return a vector with all <strong>F</strong>ourier <strong>d</strong>iscrete <strong>f</strong>requencies for a real-FFT, given sampling rate <code>sr</code> and window length <code>wl</code>. If <code>DC</code> is false, the first discrete frequency starts at bin (position) 1 and the length of the vector is wl÷2, otherwise the DC level is at position 1. and the length of the vector is (wl÷2)+1.</p><p><strong>See also</strong>: <a href="#FourierAnalysis.f2b"><code>f2b</code></a>, <a href="#FourierAnalysis.fres"><code>fres</code></a>, <a href="#FourierAnalysis.b2f"><code>b2f</code></a>, <a href="#FourierAnalysis.brange"><code>brange</code></a>.</p><p><strong>Examples</strong>:</p><pre><code class="language-none">using FourierAnalysis
fdf(8, 16)
# return the 8-element Array{Float64,1}:
# [0.5, 1.0, 1.5, 2.0, 2.5, 3, 3.5, 4.0]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/27fb14de7d3fd949536bb04a5d414211c6878e30/src/tools.jl#L158-L179">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FourierAnalysis.brange" href="#FourierAnalysis.brange"><code>FourierAnalysis.brange</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function brange(wl :: Int;
             DC :: Bool = false)</code></pre><p>Return a range of bins for a real-FFT vector covering all Fourier discrete frequencies given window length <code>wl</code>.</p><p>If <code>DC</code> is false, the range is 1:(wl÷2), otherwise it is 1:(wl÷2)+1.</p><p><strong>See also</strong>: <a href="#FourierAnalysis.f2b"><code>f2b</code></a>, <a href="#FourierAnalysis.fres"><code>fres</code></a>, <a href="#FourierAnalysis.b2f"><code>b2f</code></a>, <a href="#FourierAnalysis.fdf"><code>fdf</code></a>.</p><p><strong>Examples</strong>:</p><pre><code class="language-none">using FourierAnalysis
brange(0.5, 8) # return 1:4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/27fb14de7d3fd949536bb04a5d414211c6878e30/src/tools.jl#L186-L203">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FourierAnalysis.bbands" href="#FourierAnalysis.bbands"><code>FourierAnalysis.bbands</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function bbands(sr :: Int,
                wl :: Int,
         bandwidht :: IntOrReal;
    DC :: Bool = false)</code></pre><p>Return a vector of integers holding the limits of all <code>bandwidht</code>-spaced band-pass regions of a real-FFT, in bins of discrete Fourier frequencies, from one to <code>wl</code>÷2.</p><p>This is used by function <a href="#FourierAnalysis.bands"><code>bands</code></a>.</p><p>To know the frequencies in Hz to which these bins correspond, call <a href="#FourierAnalysis.fbands"><code>fbands</code></a>.</p><p><strong>See</strong>: <a href="#FourierAnalysis.bands"><code>bands</code></a>.</p><p><strong>See also</strong>: <a href="#FourierAnalysis.fbands"><code>fbands</code></a>.</p><p><strong>Examples</strong>:</p><pre><code class="language-none">using FourierAnalysis
bbands(128, 256, 16) # return [1, 32, 64, 96, 128]
fbands(128, 256, 16) # return [0.5, 16.0, 32.0, 48.0, 64.0]

bbands(128, 256, 16; DC=true) # return [2, 33, 65, 97, 129]
fbands(128, 256, 16; DC=true) # return [0.5, 16.0, 32.0, 48.0, 64.0]

bbands(128, 128, 16) # return [1, 16, 32, 48, 64]
fbands(128, 128, 16) # return [1.0, 16.0, 32.0, 48.0, 64.0]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/27fb14de7d3fd949536bb04a5d414211c6878e30/src/tools.jl#L208-L241">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FourierAnalysis.fbands" href="#FourierAnalysis.fbands"><code>FourierAnalysis.fbands</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function fbands(sr :: Int,
                wl :: Int,
         bandwidht :: IntOrReal;
      DC :: Bool = false)</code></pre><p>Return a vector of Frequencies (in Hz) to which the bins created by a call to function <a href="#FourierAnalysis.bbands"><code>bbands</code></a> with the same arguments correspond.</p><p><strong>See</strong>: <a href="#FourierAnalysis.bbands"><code>bbands</code></a>.</p><p><strong>See also</strong>: <a href="#FourierAnalysis.bands"><code>bands</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/27fb14de7d3fd949536bb04a5d414211c6878e30/src/tools.jl#L257-L270">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FourierAnalysis.dB" href="#FourierAnalysis.dB"><code>FourierAnalysis.dB</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">(1)
function dB(S :: Union{Real, AbstractArray{T}}) where T&lt;:Real

(2)
function dB(S1 :: Union{Real, AbstractArray{T}},
            S2 :: Union{Real, AbstractArray{T}}) where T&lt;:Real</code></pre><p>Convert (1) a measure <code>S</code>, or (2) a ratio between two measures <code>S1</code>./<code>S2</code> into deciBels.</p><p>Input measures can be real numbers or real arrays of any dimensions.</p><p>For array input, the ratio and the conversion is computed element-wise.</p><p><strong>Examples</strong>:</p><pre><code class="language-none">using FourierAnalysis
v=sinusoidal(3., 1, 128, 256, 0)
s=spectra(v, 128, 256; func=dB) # compute the spectra in dB
s.y # show the spectra

dB(s.y)

dB(10.0)

N=abs.(randn(3, 3))
dB(N)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/27fb14de7d3fd949536bb04a5d414211c6878e30/src/tools.jl#L277-L306">source</a></section><h2><a class="nav-anchor" id="specific-methods-1" href="#specific-methods-1">specific methods</a></h2><table><tr><th style="text-align: left">function</th><th style="text-align: left">description</th></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.amplitude"><code>amplitude</code></a></td><td style="text-align: left">return the amplitude (modulus) of a complex number, complex array or <a href="../timefrequency/#TFAnalyticSignal-1">TFAnalyticSignal</a> object</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.phase"><code>phase</code></a></td><td style="text-align: left">return the phase (argument) of a complex number, complex array or  <a href="../timefrequency/#TFAnalyticSignal-1">TFAnalyticSignal</a> object</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.polar"><code>polar</code></a></td><td style="text-align: left">return the phase (argument) and amplitude (modulus) of a complex number, a complex array or <a href="../timefrequency/#TFAnalyticSignal-1">TFAnalyticSignal</a> object</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.unwrapPhase"><code>unwrapPhase</code></a></td><td style="text-align: left">compute and unwrap the phase of a complex array, unwrap a real array holding phase in [−π, π], or construct a <a href="../timefrequency/#TFPhase-1">TFPhase</a> object with the phase unwrapped</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.isUnwrapped"><code>isUnwrapped</code></a></td><td style="text-align: left">return true if the phase of all objects in a <a href="../MainModule/#TFPhaseVector-1">TFPhaseVector</a> is unwrapped</td></tr></table><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FourierAnalysis.amplitude" href="#FourierAnalysis.amplitude"><code>FourierAnalysis.amplitude</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">(1)
function amplitude(c::Complex;
                        func::Function=identity) = func(abs(c))

(2)
function amplitude(A::AbstractArray{T};
                        func::Function=identity) where T&lt;:Complex

(3)
function amplitude(A::TFAnalyticSignal;
                        func::Function=identity)

(4)
function amplitude(𝐀::TFAnalyticSignalVector;
                        func::Function=identity)</code></pre><p>(1) Return the aamplitude (modulus) of a complex number. This corresponds to Julia&#39;s <a href="https://docs.julialang.org/en/v1/base/math/#Base.abs">abs</a> function. It is here provided for syntactic consistency with the following methods.</p><p>(2) Return the amplitude of a complex array <code>Z</code>. Typically, <code>Z</code> holds analytic signal, in which case the output is the analytic (instantaneous) amplitude (also known as envelope). The output is a real array of the same size as <code>Z</code>.</p><p>(3) Return a real matrix with the analytic (instantaneous) amplitude of the <a href="../timefrequency/#TFAnalyticSignal-1">TFAnalyticSignal</a> object <code>Z</code>. The output is of the same size as the data field <code>Z.y</code>.</p><p>(4) As (3), but return a vector of amplitude matrices for all <a href="../timefrequency/#TFAnalyticSignal-1">TFAnalyticSignal</a> objects in 𝐀</p><p>~</p><p>In all methods if a function is provided by the optional keyword argument <code>func</code>, it is applied element-wise to the output. For example,</p><ul><li>passing <code>func=x-&gt;x^2</code> will return the power,</li><li>passing <code>func=x-&gt;log(x^2)</code> will return the log-power,</li><li>passing <code>func=x-&gt;dB(x^2)</code> will return the power in deciBels.</li></ul><p><strong>See</strong>: <a href="../timefrequency/#TFAnalyticSignal-1">TFAnalyticSignal</a>.</p><p><strong>Examples</strong>:</p><pre><code class="language-none">using FourierAnalysis, Plots
x=sinusoidal(10, 2, 128, t*4, 0).*sinusoidal(10, 1, 128, t*4, 0)

# amplitude and phase of a vector using analytic signal standard method
y=analyticsignal(x)
a=amplitude(y)
ϕ=phase(y, func=x-&gt;(x+π)/2π*50)
plot([x, a, ϕ]; labels=[&quot;signal&quot;, &quot;amplitude&quot;, &quot;phase&quot;])

# see what happen if `x` contains energy in frequencies below sr/wl Hz
# (see documentation of `analyticSignal` function)
y=analyticsignal(x, 64)
a=amplitude(y)
ϕ=phase(y, func=x-&gt;(x+π)/2π*50)
plot([x, a, ϕ]; labels=[&quot;signal&quot;, &quot;amplitude&quot;, &quot;phase&quot;])

# unwrapped phase
# the line below will do nothing as argument `unwrapdims` is 0 by default
ϕ2=unwrapPhase(phase(y))
# this will do the job
ϕ2=unwrapPhase(phase(y); unwrapdims=1)
plot([x, a, ϕ2./25]; labels=[&quot;signal&quot;, &quot;amplitude&quot;, &quot;unwr. phase&quot;])

# amplitude from analytic signal of a data matrix holding multiple series
X=randn(t, 4)
Y=analyticsignal(X)
A=amplitude(Y)
plot(A[:, 1:2])

# phase
𝛷=phase(Y)
plot(𝛷[:, 1:1])

# unwrapped phase
𝛷2=unwrapPhase(𝛷; unwrapdims=1)
plot(𝛷2)

# phase represented in [-1, 1]
𝛷=phase(Y, func=x-&gt;(x+π)/2π)
plot(𝛷[:, 1:1])

# sine of the phase
𝛷=phase(Y, func=sin)
plot(𝛷[:, 1:1])

# get Amplitude and phase from analytic Signal
A, 𝛷=polar(Y)
A
𝛷</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/27fb14de7d3fd949536bb04a5d414211c6878e30/src/tools.jl#L312-L413">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FourierAnalysis.phase" href="#FourierAnalysis.phase"><code>FourierAnalysis.phase</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">(1)
function phase(z::Complex; func::Function=identity)

(2)
function phase(Z::AbstractArray{T};
                        unwrapdims::Int=0,
                        func::Function=identity) where T&lt;:Complex

(3)
function phase(Z::TFAnalyticSignal;
                        unwrapped::Bool=false,
                        func::Function=identity)

(4)
function phase(𝐙::TFAnalyticSignalVector;
                        unwrapped::Bool=false,
                        func::Function=identity)
</code></pre><p>(1) Return the phase (argument) of a complex number. This corresponds to a standard <a href="https://en.wikipedia.org/wiki/Atan2">atan2</a> function. It is here provided for syntactic consistency with the following methods.</p><p>(2) Return the phase of a complex array <code>Z</code>. Typically, <code>Z</code> holds analytic signal, in which case the output is the analytic (instantaneous) phase. The output is a real array of the same size as <code>Z</code>.</p><p>If optional keyword argument <code>unwrapdims</code> is &gt; 0, return the unwrapped phase along the <code>unwrapdims</code> dimension of the array. For example, if <code>Z</code> is a matrix, passing <code>unwrapdims=1</code> unwrap the phase indipendently along its columns.</p><p>(3) Return a real matrix with the analytic (instantaneous) phase of the <a href="../timefrequency/#TFAnalyticSignal-1">TFAnalyticSignal</a> object <code>Z</code>. The output is of the same size as the data field <code>Z.y</code>.</p><p>If optional keyword argument <code>unwrapped</code> is true, return the unwrapped phase along the time dimension of the analytic signal (dims=2).</p><p>(4) As (3), but return a vector of phase matrices for all <a href="../timefrequency/#TFAnalyticSignal-1">TFAnalyticSignal</a> objects in 𝚯.</p><p>~</p><p>In all methods by default the phase is returned in [−π, π]. If a function is provided by the optional keyword argument <code>func</code>, it is applied to the phase. For example</p><ul><li>passing <code>func=x-&gt;x+π</code> will return the phase in [0, 2π],</li><li>passing <code>func=x-&gt;x/π</code> will return the phase in [-1, 1],</li><li>passing <code>func=sin</code> will return the sine of the phase.</li></ul><p>!!! note Nota Bene     If in method (2) <code>unwrapdims</code> is &gt;0 or in method (3) and (4)     <code>unwrapped</code> is true, the function <code>func</code> is applied to the unwrapped phase.</p><p><strong>See</strong>: <a href="#FourierAnalysis.unwrapPhase"><code>unwrapPhase</code></a>, <a href="../timefrequency/#TFAnalyticSignal-1">TFAnalyticSignal</a>.</p><p><strong>Examples</strong>: see examples of <a href="#FourierAnalysis.amplitude"><code>amplitude</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/27fb14de7d3fd949536bb04a5d414211c6878e30/src/tools.jl#L429-L494">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FourierAnalysis.polar" href="#FourierAnalysis.polar"><code>FourierAnalysis.polar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">(1)
function polar(c::Complex)

(2)
function polar(Z::AbstractArray{T}) where T&lt;:Complex

(3)
function polar(Z::TFAnalyticSignal)
</code></pre><p>(1) Return the amplitude (modulus) and phase (argument) of a complex number as a 2-tuple.</p><p>(2) Return the amplitude and phase of a complex array <code>Z</code>. Typically, <code>Z</code> holds analytic signal, in which case return the analytic (instantaneous) amplitude and phase. The output is a tuple of two real arrays of the same size as data field <code>Z.y</code>.</p><p>(3) Return the analytic (instantaneous) amplitude and phase of the <a href="../timefrequency/#TFAnalyticSignal-1">TFAnalyticSignal</a> object <code>Z</code>. The output is a tuple of two real arrays of the same size as data field <code>Z.y</code>.</p><p>~</p><p>In all methods the phase is returned in [−π, π].</p><p><strong>See</strong>: <a href="#FourierAnalysis.amplitude"><code>amplitude</code></a>, <a href="#FourierAnalysis.phase"><code>phase</code></a>, <a href="../timefrequency/#TFAnalyticSignal-1">TFAnalyticSignal</a>.</p><p><strong>Examples</strong>: see examples of <a href="#FourierAnalysis.amplitude"><code>amplitude</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/27fb14de7d3fd949536bb04a5d414211c6878e30/src/tools.jl#L508-L543">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FourierAnalysis.unwrapPhase" href="#FourierAnalysis.unwrapPhase"><code>FourierAnalysis.unwrapPhase</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">(1)
function unwrapPhase(Z::AbstractArray{T};
                                unwrapdims::Int=0) where T&lt;:Complex

(2)
function unwrapPhase(ϴ::AbstractArray{T};
                                unwrapdims::Int=0) where T&lt;:Real

(3)
unwrapPhase(ϴ::TFPhase) [constructor of a TFPhase object]

(4)
unwrapPhase(𝚯::TFPhaseVector) [constructor of a TFPhaseVector object]</code></pre><p>(1) If optional keyword argument <code>unwrapdims</code> is &gt; 0, compute the phase (argument) from a <em>complex</em> array and unwrap it along the <code>unwrapdims</code> dimension, otherwise (default) return <code>Z</code>. Typically, <code>Z</code> holds analytic signal.</p><p>(2) If optional keyword argument <code>unwrapdims</code> is &gt; 0, unwrap along the <code>unwrapdims</code> dimension a <em>real</em> array holding phase data in [−π, π], otherwise return <code>ϴ</code>.</p><p>(3) Construct a <a href="../timefrequency/#TFPhase-1">TFPhase</a> object by unwrapping its phase along the time dimension and copying all other fields from the <code>ϴ</code> object. If <code>ϴ.func</code> is different from the <code>identity</code> (do nothing) function, return instead an error message.</p><p>(4) As (3), but conctruct a <a href="../MainModule/#TFPhaseVector-1">TFPhaseVector</a> holding <a href="../timefrequency/#TFPhase-1">TFPhase</a> objects in 𝚯 with the phase unwrapped. <code>ϴ.func</code> must be the identity function for all ϴ ∈ 𝚯.</p><p>The unwrapped phase is defined as the cumulative sum of the phase (along the relevant dimension) once this is represented in [0, 2π].</p><p><strong>Examples</strong>: see examples of <a href="#FourierAnalysis.amplitude"><code>amplitude</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/27fb14de7d3fd949536bb04a5d414211c6878e30/src/tools.jl#L561-L604">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FourierAnalysis.isUnwrapped" href="#FourierAnalysis.isUnwrapped"><code>FourierAnalysis.isUnwrapped</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">(1)
function isUnwrapped(ϴ::TFPhase)

(2)
function isUnwrapped(𝚯::TFPhaseVector)</code></pre><p>(1) Return true if the TFPhase objects ϴ have the phase unwrapped.</p><p>(2) Return true if all TFPhase objects in 𝚯 have the phase unwrapped.</p><p><strong>See</strong>: <a href="#FourierAnalysis.unwrapPhase"><code>unwrapPhase</code></a>, <a href="../timefrequency/#TFPhase-1">TFPhase</a>, <a href="../MainModule/#TFPhaseVector-1">TFPhaseVector</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/27fb14de7d3fd949536bb04a5d414211c6878e30/src/tools.jl#L725-L740">source</a></section><h2><a class="nav-anchor" id="generic-methods-1" href="#generic-methods-1">generic methods</a></h2><p><strong>Generic methods</strong> applying to <a href="../MainModule/#FDobjects-1">FDobjects</a>, <a href="../MainModule/#FDobjectsVector-1">FDobjectsVector</a>, <a href="../MainModule/#TFobjects-1">TFobjects</a> and <a href="../MainModule/#TFobjectsVector-1">TFobjectsVector</a>:</p><table><tr><th style="text-align: left">function</th><th style="text-align: left">description</th></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.smooth"><code>smooth</code></a></td><td style="text-align: left">smooth the data across frequencies and/or across time</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.extract"><code>extract</code></a></td><td style="text-align: left">extract the data in a frequency or time-frequency region</td></tr><tr><td style="text-align: left"><a href="#Statistics.mean"><code>mean</code></a></td><td style="text-align: left">compute the mean in a frequency or time-frequency region</td></tr></table><p>¤</p><p><strong>Generic methods</strong> applying only to <a href="../MainModule/#FDobjects-1">FDobjects</a> and <a href="../MainModule/#FDobjectsVector-1">FDobjectsVector</a>:</p><table><tr><th style="text-align: left">function</th><th style="text-align: left">description</th></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.bands"><code>bands</code></a></td><td style="text-align: left">Return band-pass average of spectral, cross-spectral or coherence estimates in equally spaced band-pass regions</td></tr></table><p>¤</p><p><strong>Generic methods</strong> applying to <a href="../MainModule/#FDobjectsVector-1">FDobjectsVector</a>, and <a href="../MainModule/#TFobjectsVector-1">TFobjectsVector</a>:</p><table><tr><th style="text-align: left">function</th><th style="text-align: left">description</th></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.sameParams"><code>sameParams</code></a></td><td style="text-align: left">return true if the non-data fields of all objects in the vector have the same value</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.isLinear"><code>isLinear</code></a></td><td style="text-align: left">return true if all objects in the vector are linear</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.isNonLinear"><code>isNonLinear</code></a></td><td style="text-align: left">return true if all objects in the vector are non-linear</td></tr></table><p>¤</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FourierAnalysis.smooth" href="#FourierAnalysis.smooth"><code>FourierAnalysis.smooth</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">(1)
function smooth(smoother :: Smoother,
                       S :: Union{Vector{&lt;:Real}, Vector{&lt;:Complex}})

(2)
function smooth(smoother :: Smoother,
                       S :: Union{FDobjects, FDobjectsVector})

(3)
function smooth(fsmoothing :: Smoother,
                tsmoothing :: Smoother,
                         Y :: Union{TFobjects, TFobjectsVector})</code></pre><p>Apply a smoothing function of type <a href="../MainModule/#Smoother::Enumerated-Type-1">Smoother::Enumerated Type</a> to</p><ul><li>(1) a vector of real or complex numbers,</li><li>(2) a <a href="../MainModule/#FDobjects-1">FDobjects</a> or all objects in a <a href="../MainModule/#FDobjectsVector-1">FDobjectsVector</a>,</li><li>(3) a <a href="../MainModule/#TFobjects-1">TFobjects</a> or all objects in a <a href="../MainModule/#TFobjectsVector-1">TFobjectsVector</a>.</li></ul><p>This function is a constructor; for all methods the output is always of the same type as the input.</p><p>Method (1) is provided for low-level computations, but typically it is not needed.</p><p>Method (2) smooths across the frequency dimension:</p><ul><li>for <a href="../spectra/#Spectra-1">Spectra</a> objects this amounts to smoothing the column vectors in their <code>.y</code> field,</li><li>for <a href="../crossspectra/#CrossSpectra-1">CrossSpectra</a> and <a href="../coherence/#Coherence-1">Coherence</a> objects this amounts to smoothing adjacent matrices in their .y field.</li></ul><p>Method (3) smooths across the frequency dimension, time dimension or both. This amount to smooth across the column vectors (frequency) and/or row vectors (time) in the <code>.y</code> field of the object. A smoother must be specified for the frequency dimension (<code>fsmoothing</code>) and for the time dimension (<code>tsmoothing</code>). Either one may be <code>noSmoother</code>, but if the two are different from <code>noSmoother</code>, then they must be the same. If smoothing is requested in both the frequency and time dimension, then the data is smoothed indipendently in those dimensions and the result of the two smoothings is averaged. For <a href="../timefrequency/#TFPhase-1">TFPhase</a> objects, smoothing is allowed only if the phase is unwrapped.</p><p>This function allow smoothing frequency domain and time-frequency domain objects after they have been created, however, smoothing can also be requested upon creation. For example, see the documentation of <a href="../spectra/#Spectra-1">Spectra</a>.</p><div class="admonition note"><div class="admonition-title">Nota Bene</div><div class="admonition-text"><p>For methods (1) and (2), if <code>Smoother</code> is <code>noSmoother</code>, then the input is returned unchanged. For method (3) this is the case if both <code>fsmoother</code> and <code>tsmoother</code> are <code>noSmoother</code>.</p><p>The data input must hold in the concerned dimension at least three elements for applying an Hann or Hamming smoother and at least five elements for applying the Blackman smoother.</p></div></div><p><strong>Maths</strong></p><p>Smoothing of a series <span>$x$</span> composed of <span>$k$</span> elements is carried out at element <span>$i$</span> such as</p><p><span>$x_{i}=ax_{i-2}+bx_i{-1}+cx_{i}+bx_{i+1}+ax_{i+2}$</span>.</p><p>The coefficients are</p><table><tr><th style="text-align: center">smoothing window</th><th style="text-align: center">a</th><th style="text-align: center">b</th><th style="text-align: center">c</th></tr><tr><td style="text-align: center">Hann</td><td style="text-align: center">0</td><td style="text-align: center">0.25</td><td style="text-align: center">0.50</td></tr><tr><td style="text-align: center">Hamming</td><td style="text-align: center">0</td><td style="text-align: center">0.23</td><td style="text-align: center">0.54</td></tr><tr><td style="text-align: center">Blackman</td><td style="text-align: center">0.04</td><td style="text-align: center">0.25</td><td style="text-align: center">0.42</td></tr></table><p>For 3-point smoothers, the first point is smoothed as</p><p><span>$x_{1}=\frac{c}{b+c}x_{1} + \frac{b}{b+c}x_{2}$</span></p><p>and the last (the <span>$k^(th)$</span>) as</p><p><span>$x_{k}=\frac{c}{b+c}x_{k} + \frac{b}{b+c}x_{k-1}$</span>.</p><p>For 5-point smoothers, the first point is smoothed as</p><p><span>$x_{1}=\frac{c}{a+b+c}x_{1} + \frac{b}{a+b+c}x_{2} + \frac{a}{a+b+c}x_{3}$</span>,</p><p>the second as</p><p><span>$x_{2}=\frac{b}{a+2b+c}x_{1} + \frac{c}{a+2b+c}x_{2} + \frac{b}{a+2b+c}x_{3} + \frac{a}{a+2b+c}x_{4}$</span>,</p><p>the second to last as</p><p><span>$x_{k-1}=\frac{a}{a+2b+c}x_{k-3} + \frac{b}{a+2b+c}x_{k-2} + \frac{c}{a+2b+c}x_{k-1} + \frac{b}{a+2b+c}x_{k}$</span></p><p>and the last as</p><p><span>$x_{k}=\frac{a}{a+b+c}x_{k-2} + \frac{b}{a+b+c}x_{k-1} + \frac{c}{a+b+c}x_{k}$</span>.</p><p><strong>See</strong>: <a href="../MainModule/#Smoother::Enumerated-Type-1">Smoother::Enumerated Type</a></p><p><strong>Examples</strong>:</p><pre><code class="language-none">using FourierAnalysis, Plots
sr, t, f, a = 128, 128, 10, 0.5
# create a sinusoidal superimposed to white noise
v=sinusoidal(a, f, sr, t*16, 0) + randn(t*16)
# compute Amplitude Spectra
Σ=spectra(v, sr, t; func=√)
bar(Σ.y, labels=&quot;raw amplitude spectra&quot;)

#smooth spectra
Σ2=smooth(blackmanSmoother, Σ)
bar!(Σ2.y, labels=&quot;smoothed amplitude spectra&quot;)

# smooth cross-spectra (or coherence) matrices
X=broadcast(+, v, randn(t*16, 3))*randn(3, 3)
S=crossSpectra(X, sr, t) # or coherence (X, sr, t)
# smooth the cross-spectra # or coherence
S2=smooth(blackmanSmoother, S)

# smooth time-frequency object
Y = TFanalyticsignal(v, sr, sr*4)
# smooth frequency
Z=smooth(blackmanSmoother, noSmoother, Y)
# plot amplitude of smoothed analytic signal
heatmap(Z, amplitude)

# smooth AS: smooth both frequency and time
E=smooth(blackmanSmoother, blackmanSmoother, Y)
# plot real part of smoothed analytic signal
heatmap(Z, real)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/27fb14de7d3fd949536bb04a5d414211c6878e30/src/tools.jl#L813-L939">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FourierAnalysis.extract" href="#FourierAnalysis.extract"><code>FourierAnalysis.extract</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">(1)
function extract(S :: FDobjects,
            frange :: fInterval)

(2)
function extract(𝐒 :: FDobjectsVector,
            frange :: fInterval;
        w :: Vector = [],
    check :: Bool   = true)

(3)
function extract(Y :: TFobjects,
            frange :: fInterval,
            trange :: tInterval)

(4)
function extract(𝒀 :: TFobjectsVector,
            frange :: fInterval,
            trange :: tInterval;
        w :: Vector = [],
    check :: Bool   = true)</code></pre><p><strong>alias</strong>: <code>extr</code></p><p>Extract data in a frequency region from <a href="../MainModule/#FDobjects-1">FDobjects</a> and data in a time-frequency region from <a href="../MainModule/#TFobjects-1">TFobjects</a>. The frequency and time region are indicated by <code>frange</code> and <code>trange</code>, which are of type <a href="../MainModule/#fInterval-1">fInterval</a> and <a href="../MainModule/#tInterval-1">tInterval</a>, respectively.</p><p>The input/output types of this function for a region with more then one frequency and more than one sample is reported in the following table:</p><table><tr><th style="text-align: center">method</th><th style="text-align: left">input object</th><th style="text-align: left">output</th></tr><tr><td style="text-align: center">(1.1)</td><td style="text-align: left"><a href="../spectra/#Spectra-1">Spectra</a></td><td style="text-align: left">a real matrix with spectra in <code>frange</code> arranged in columns¹</td></tr><tr><td style="text-align: center">(1.2)</td><td style="text-align: left"><a href="../crossspectra/#CrossSpectra-1">CrossSpectra</a></td><td style="text-align: left">a vector of complex matrices holding the cross-spectra in <code>frange</code>²</td></tr><tr><td style="text-align: center">(1.3)</td><td style="text-align: left"><a href="../coherence/#Coherence-1">Coherence</a></td><td style="text-align: left">a vector of real matrices holding the coherence in <code>frange</code>²</td></tr><tr><td style="text-align: center">(2.1)</td><td style="text-align: left"><a href="../MainModule/#SpectraVector-1">SpectraVector</a></td><td style="text-align: left">a vector of matrices of type (1.1)</td></tr><tr><td style="text-align: center">(2.2)</td><td style="text-align: left"><a href="../MainModule/#CrossSpectraVector-1">CrossSpectraVector</a></td><td style="text-align: left">a vector of vectors of type (1.2)</td></tr><tr><td style="text-align: center">(2.3)</td><td style="text-align: left"><a href="../MainModule/#CoherenceVector-1">CoherenceVector</a></td><td style="text-align: left">a vector of vectors of type (1.3)</td></tr><tr><td style="text-align: center">(3.1)</td><td style="text-align: left"><a href="../timefrequency/#TFAnalyticSignal-1">TFAnalyticSignal</a></td><td style="text-align: left">a complex matrix holding the analytic signal in [<code>frange</code>, <code>trange</code>]</td></tr><tr><td style="text-align: center">(3.2)</td><td style="text-align: left"><a href="../timefrequency/#TFAmplitude-1">TFAmplitude</a></td><td style="text-align: left">a real matrix holding the amplitude in [<code>frange</code>, <code>trange</code>]</td></tr><tr><td style="text-align: center">(3.3)</td><td style="text-align: left"><a href="../timefrequency/#TFPhase-1">TFPhase</a></td><td style="text-align: left">a real matrices holding the phase in [<code>frange</code>, <code>trange</code>]</td></tr><tr><td style="text-align: center">(4.1)</td><td style="text-align: left"><a href="../MainModule/#TFAnalyticSignalVector-1">TFAnalyticSignalVector</a></td><td style="text-align: left">a vector of matrices of type (3.1)</td></tr><tr><td style="text-align: center">(4.2)</td><td style="text-align: left"><a href="../MainModule/#TFAmplitudeVector-1">TFAmplitudeVector</a></td><td style="text-align: left">a vector of matrices of type (3.2)</td></tr><tr><td style="text-align: center">(4.3)</td><td style="text-align: left"><a href="../MainModule/#TFPhaseVector-1">TFPhaseVector</a></td><td style="text-align: left">a vector of matrices of type (3.3)</td></tr></table><p>Legend: ¹ <em>each column refers to a series on which the spectra have been computed.</em> ² *depending on how the objects has been created, the matrices may be either Hermitian or LowerTriangular. See the documentation of <a href="../crossspectra/#CrossSpectra-1">CrossSpectra</a> and <a href="../coherence/#Coherence-1">Coherence</a>.</p><p>Note that depending on the arguments the type of the output may loose one or two dimensions. For instance,</p><ul><li>if the <a href="../spectra/#Spectra-1">Spectra</a> object holds only one spectrum, (1.1) will output a column vector and (2.1) a vector of column vectors.</li><li>if <code>frange</code> points to a single frequency, (1.1) will output a row vector and (2.1) a vector of row vectors.</li><li>if both the above two conditions hold, (1.1) will output a real number and (2.1) a vector.</li><li>if <code>frange</code> points to a single frequency, (1.2), (1.3) will output a matrix and (2.2), (2.3) a vector of matrices.</li><li>If <code>frange</code> points to a single frequency band, (3.1), (3.2), (3.3) will output a row vector and (4.1), (4.2), (4.3) a vector of row vectors.</li><li>If <code>trange</code> points to a single time sample, (3.1), (3.2), (3.3) will output a column vector and (4.1), (4.2), (4.3) a vector of column vectors.</li><li>if both the above two conditions hold, (3.1), (3.2), (3.3) will output a number and (4.1), (4.2), (4.3) a vector.</li></ul><p>Method (2) and (4) allows the following <em>optional keyword arguments</em>:</p><p><code>w</code>, a <span>$k$</span>-vector of non-negative integers or real numbers, where <span>$k$</span> is the numbers of objects hold in the input <a href="../MainModule/#FDobjectsVector-1">FDobjectsVector</a> or <a href="../MainModule/#TFobjectsVector-1">TFobjectsVector</a>. <code>w</code> is a vector of weights for the regions extracted from the input objects. By default, no weights are assigned.</p><p><code>check</code>, a boolean. If it is true, it is checked that the non-data fields of the input objects are all the same (for example, sampling rate, bandwidht, etc.).</p><p><strong>See also</strong>: <a href="#Statistics.mean"><code>mean</code></a>.</p><p><strong>Examples</strong>:</p><pre><code class="language-none">using FourierAnalysis, Plots

# example with univariate Spectra objects (one series -&gt; one spectrum)
sr, t, f, a = 128, 256, 10, 1
# create a sinusoidal superimposed to white noise
v=sinusoidal(a, f, sr, t*16, 0) + randn(t*16)
# compute univariate spectra
Σ=spectra(v, sr, t)
# spectra in between 8Hz and 12Hz
s=extract(Σ, (8, 12))
# spectra in between 8Hz and 12.5Hz
s=extract(Σ, (8, 12.5))
# spectra at 10Hz
s=extract(Σ, 10) # or s=extract(S, (10, 10))
# these two expressions are equivalent: s=extract(Σ, :), s=Σ.y

# example with multivariate spectra (several series -&gt; several spectra)
Σ=spectra(hcat(v, v+randn(t*16)), sr, t)
# spectra in between 8Hz and 12Hz
S=extract(Σ, (8, 12))
# spectra at 10Hz
S=extract(Σ, 10)

# example with CrossSpectra objects (the same goes for Coherence objects)
X=broadcast(+, v, randn(t*16, 3))*randn(3, 3)
Σ=crossSpectra(X, sr, t)
# cross-spectra in between 8Hz and 12Hz (Hermitian matrices)
S=extract(Σ, (8, 12))
Σ=crossSpectra(X, sr, t; tril=true)
# cross-spectra in between 8Hz and 12Hz (LowerTriangular matrices)
S=extract(Σ, (8, 12))

# example with multiple cross-spectra
X2=broadcast(+, v, randn(t*16, 3))*randn(3, 3)
Σ=crossSpectra([X, X2], sr, t) # this is a CrossSpectraVector
S=extract(Σ, (8, 12); w=[0.4, 0.6])
# now S[1] holds the cross-spectra in range 8-12Hz for X
# and S[2] holds the cross-spectra in range 8-12Hz for X2

# example with time-frequency objects
# (work in the same way for TFAnalyticSignal, TFAmplitude and TFPhase)
Y = TFanalyticsignal(v, sr, t)
# analytic signal within frequencies 8Hz and 12Hz and time samples 1 to 64.
AS=extract(Y, (8, 12), (1, 64))

# all analytic signal within frequencies 8Hz and 12Hz.
AS=extract(Y, (8.0, 12), :) # accept integers and reals for frequencies

# all analytic signal within time samples 1 to 64.
AS=extract(Y, :, (1, 64))

# example with multiple time-frequency objects
# (notice how the type of the output changes)
Y = TFanalyticsignal([v, v+randn(t*16)], sr, t)
AS=extract(Y, (8, 12), (1, 64))
AS=extract(Y, (8), :)
AS=extract(Y, 8, 2)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/27fb14de7d3fd949536bb04a5d414211c6878e30/src/tools.jl#L1082-L1217">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Statistics.mean" href="#Statistics.mean"><code>Statistics.mean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">(1)
function mean(S :: FDobjects,
         frange :: fInterval)

(2)
function mean(𝐒 :: FDobjectsVector,
         frange :: fInterval;
        w :: Vector = [],
    check :: Bool   = true)

(3)
function mean(Y :: TFobjects,
         frange :: fInterval,
         trange :: tInterval)

(4)
function mean(𝒀 :: TFobjectsVector,
         frange :: fInterval,
         trange :: tInterval;
          w :: Vector = [],
      check :: Bool   = true)</code></pre><p>Return the mean of data in a frequency region from <a href="../MainModule/#FDobjects-1">FDobjects</a> and data in a time-frequency region from <a href="../MainModule/#TFobjects-1">TFobjects</a>. The frequency and time region are indicated by <code>frange</code> and <code>trange</code>, which are of type <a href="../MainModule/#fInterval-1">fInterval</a> and <a href="../MainModule/#fInterval-1">fInterval</a>, respectively.</p><p>The complete input/output types for this function is reported in the following table:</p><table><tr><th style="text-align: center">method</th><th style="text-align: left">input object</th><th style="text-align: left">output</th></tr><tr><td style="text-align: center">(1.1)</td><td style="text-align: left"><a href="../spectra/#Spectra-1">Spectra</a></td><td style="text-align: left">a vector holding the mean spectra in <code>frange</code>¹</td></tr><tr><td style="text-align: center">(1.2)</td><td style="text-align: left"><a href="../crossspectra/#CrossSpectra-1">CrossSpectra</a></td><td style="text-align: left">a complex matrix holding the mean cross-spectra in <code>frange</code>²</td></tr><tr><td style="text-align: center">(1.3)</td><td style="text-align: left"><a href="../coherence/#Coherence-1">Coherence</a></td><td style="text-align: left">a real matrix holding the mean coherence in <code>frange</code>²</td></tr><tr><td style="text-align: center">(2.1)</td><td style="text-align: left"><a href="../MainModule/#SpectraVector-1">SpectraVector</a></td><td style="text-align: left">a vector of vectors of type (1.1)</td></tr><tr><td style="text-align: center">(2.2)</td><td style="text-align: left"><a href="../MainModule/#CrossSpectraVector-1">CrossSpectraVector</a></td><td style="text-align: left">a vector of matrices of type (1.2)</td></tr><tr><td style="text-align: center">(2.3)</td><td style="text-align: left"><a href="../MainModule/#CoherenceVector-1">CoherenceVector</a></td><td style="text-align: left">a vector of matrices of type (1.3)</td></tr><tr><td style="text-align: center">(3.1)</td><td style="text-align: left"><a href="../timefrequency/#TFAnalyticSignal-1">TFAnalyticSignal</a></td><td style="text-align: left">a complex number holding the mean analytic signal in [<code>frange</code>, <code>trange</code>]</td></tr><tr><td style="text-align: center">(3.2)</td><td style="text-align: left"><a href="../timefrequency/#TFAmplitude-1">TFAmplitude</a></td><td style="text-align: left">a real number holding the mean amplitude in [<code>frange</code>, <code>trange</code>]</td></tr><tr><td style="text-align: center">(3.3)</td><td style="text-align: left"><a href="../timefrequency/#TFPhase-1">TFPhase</a></td><td style="text-align: left">a real number holding the mean phase in [<code>frange</code>, <code>trange</code>]</td></tr><tr><td style="text-align: center">(4.1)</td><td style="text-align: left"><a href="../MainModule/#TFAnalyticSignalVector-1">TFAnalyticSignalVector</a></td><td style="text-align: left">a vector of numbers of type (3.1)</td></tr><tr><td style="text-align: center">(4.2)</td><td style="text-align: left"><a href="../MainModule/#TFAmplitudeVector-1">TFAmplitudeVector</a></td><td style="text-align: left">a vector of numbers of type (3.2)</td></tr><tr><td style="text-align: center">(4.3)</td><td style="text-align: left"><a href="../MainModule/#TFPhaseVector-1">TFPhaseVector</a></td><td style="text-align: left">a vector of numbers of type (3.3)</td></tr></table><p>legend: ¹<em>each element of the vector refers to a series on which the spectra have been computed.</em> ² <em>depending on how the objects has been created, the matrices may be either Hermitian or LowerTriangular.</em></p><p>Method (2) and (4) allows the following <em>optional keyword arguments</em>:</p><p><code>w</code>, a <span>$k$</span>-vector of non-negative integers or real numbers, where <span>$k$</span> is the numbers of objects hold in the input <a href="../MainModule/#FDobjectsVector-1">FDobjectsVector</a> or <a href="../MainModule/#TFobjectsVector-1">TFobjectsVector</a>. <code>w</code> is a vector of weights for the means extracted from the input objects. By default, no weights are assigned.</p><p><code>check</code>, a boolean. If it is true, it is checked that the non-data fields of the input objects are all the same (for example, sampling rate, bandwidht, etc.).</p><p><strong>See also</strong>: <a href="#FourierAnalysis.extract"><code>extract</code></a>.</p><p><strong>Examples</strong>:</p><pre><code class="language-none">using FourierAnalysis, Plots

# example with univariate Spectra objects (one series -&gt; one spectrum)
sr, t, f, a = 128, 256, 10, 1
# create a sinusoidal superimposed to white noise
v=sinusoidal(a, f, sr, t*16, 0) + randn(t*16)
# compute the spectrum
Σ=spectra(v, sr, t)
# mean spectrum in between 8Hz and 12Hz
s=mean(Σ, (8, 12))
# mean spectrum in between 8Hz and 12.5Hz
s=mean(Σ, (8, 12.5))

# example with multivariate spectra (several series -&gt; several spectra)
Σ=spectra(hcat(v, v+randn(t*16)), sr, t)
# mean spectra in between 8Hz and 12Hz
S=mean(Σ, (8, 12))
# mean spectra at 10Hz, i.e., the spectra at 10Hz
S=mean(Σ, 10)

# example with CrossSpectra objects (the same goes for Coherence objects)
X=broadcast(+, v, randn(t*16, 3))*randn(3, 3)
Σ=crossSpectra(X, sr, t)
# mean cross-spectra in between 8Hz and 12Hz (an Hermitian matrix)
S=mean(Σ, (8, 12))
Σ=crossSpectra(X, sr, t; tril=true)
# mean cross-spectra in between 8Hz and 12Hz (a LowerTriangular matrix)
S=mean(Σ, (8.0, 12.0)) # accept integers and reals for frequencies

# example with multiple CrossSpectra objects
X2=broadcast(+, v, randn(t*16, 3))*randn(3, 3)
Σ=crossSpectra([X, X2], sr, t) # this is a CrossSpectraVector
S=mean(Σ, (8, 12); w=[0.4, 0.6])
# now S[1] will hold the mean cross-spectrum in range 8-12Hz for X
# and S[2] will hold the mean cross-spectrum in range 8-12Hz for X2

# example with time-frequency objects
# (work in the same way for TFAnalyticSignal, TFAmplitude and TFPhase)
Y = TFanalyticsignal(v, sr, t)
# mean analytic signal within frequencies 8Hz and 12Hz and time samples 1 to 64.
as=mean(Σ, (8, 12), (1, 64))
# mean analytic signal within frequencies 8Hz and 12Hz.
as=mean(Σ, (8, 12), :)
# mean analytic signal within time samples 1 to 64.
as=mean(Σ, :, (1, 64))

# example with multiple time-frequency objects
Y = TFanalyticsignal([v, v+randn(t*16)], sr, t)
AS=mean(Y, (8, 12), (1, 64))
# get the mean across TFobjects of those means
m=mean(mean(Y, (8, 12), (1, 64)))
AS=mean(Y, (8), :)
AS=mean(Y, 8, 2)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/27fb14de7d3fd949536bb04a5d414211c6878e30/src/tools.jl#L1231-L1349">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FourierAnalysis.bands" href="#FourierAnalysis.bands"><code>FourierAnalysis.bands</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function bands(S :: Union{FDobjects, FDobjectsVector}
       bandwidht :: IntOrReal)</code></pre><p>Return band-pass average of spectral, cross-spectral or coherence estimates in equally spaced band-pass regions with the given <code>bandwidht</code>. <code>bandwidht</code> can be given as an integer or as a real number. See <a href="#FourierAnalysis.bbands"><code>bbands</code></a> for details on the definition of band-pass regions.</p><p>Band-pass average is not supported for TimeFrequency objects as for those objects a similar averaging is natively avaiable using argument <code>bandwidht</code> in their constructors.</p><p>The output of this function is as it follows:</p><ul><li>for univariate <a href="../spectra/#Spectra-1">Spectra</a> objects (i.e., those hodling one spectrum only), a real column vector,</li><li>for multivariate <a href="../spectra/#Spectra-1">Spectra</a> objects, a real matrix,</li><li>for <a href="../MainModule/#SpectraVector-1">SpectraVector</a> objects, a vector of the above,</li><li>for <a href="../crossspectra/#CrossSpectra-1">CrossSpectra</a> and <a href="../coherence/#Coherence-1">Coherence</a> objects, a vector of Hermitian or LowerTriangular matrices, depending on how the object has been cosntructed,</li><li>for <a href="../MainModule/#CrossSpectraVector-1">CrossSpectraVector</a> and <a href="../MainModule/#CoherenceVector-1">CoherenceVector</a> objects, a vector  of the above.</li></ul><p><strong>See</strong>: <a href="#FourierAnalysis.bbands"><code>bbands</code></a>.</p><p><strong>Examples</strong>:</p><pre><code class="language-none">using FourierAnalysis, Plots

# example with univariate Spectra objects (one series -&gt; one spectrum)
sr, t, f, a = 128, 256, 10, 1
# create a sinusoidal superimposed to white noise
v=sinusoidal(a, f, sr, t*16, 0) + randn(t*16)
# compute the spectrum
Σ=spectra(v, sr, t)
# mean spectra in 2Hz-band-pass regions
b=bands(Σ, 2)
plot(b)

# example with multivariate spectra (several series -&gt; several spectra)
Σ=spectra(hcat(v, v+randn(t*16), v+randn(t*16) ), sr, t)
# mean spectra in 2Hz-band-pass regions for all time-series
b=bands(Σ, 2)
plot(b)
# plot mean spectra in 2Hz-band-pass regions for time-series 2 and 3 only
plot(bands(Σ, 2)[:, 2:3])

# example with CrossSpectra objects (the same goes for Coherence objects)
X=broadcast(+, v, randn(t*16, 3))*randn(3, 3)
Σ=crossSpectra(X, sr, t)
# mean cross-spectra in 4Hz-band-pass regions
B=bands(Σ, 4)

# example with multiple CrossSpectra objects
X2=broadcast(+, v, randn(t*16, 3))*randn(3, 3)
Σ=crossSpectra([X, X2], sr, t) # this is a CrossSpectraVector
# mean cross-spectra in 4Hz-band-pass regions for all cross-spectra objects
B=bands(Σ, 4)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/27fb14de7d3fd949536bb04a5d414211c6878e30/src/tools.jl#L1462-L1520">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FourierAnalysis.sameParams" href="#FourierAnalysis.sameParams"><code>FourierAnalysis.sameParams</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function sameParams(𝐒        :: FDobjectsVector,
                    funcname :: String)</code></pre><p>Return true if all objects in 𝐒 have the same <code>sr</code>, <code>wl</code>, <code>DC</code>, <code>taper</code>, <code>func</code>(only for <a href="../MainModule/#SpectraVector-1">SpectraVector</a> objects), <code>nonlinear</code> (only for <a href="../MainModule/#CrossSpectraVector-1">CrossSpectraVector</a> and <a href="../MainModule/#CoherenceVector-1">CoherenceVector</a>) and <code>smoothing</code> fields, otherwise print an error message pointing to the first field that is not identical in all objects and return <code>Nothing</code>. This method applies to all <a href="../MainModule/#FDobjectsVector-1">FDobjectsVector</a> types, that is, to <a href="../MainModule/#SpectraVector-1">SpectraVector</a>, <a href="../MainModule/#CrossSpectraVector-1">CrossSpectraVector</a> and <a href="../MainModule/#CoherenceVector-1">CoherenceVector</a>.</p><p><code>funcname</code> is an optional string that the user can provide. It is inserted into the error message to locate the part of the code that generated the error. By defalut, &quot;unknown&quot; is used.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/27fb14de7d3fd949536bb04a5d414211c6878e30/src/tools.jl#L627-L646">source</a><div><div><pre><code class="language-none">function sameParams(𝒀        :: TFobjectsVector,
                    funcname :: String) =</code></pre><p>Return true if all objects in 𝒀 have the same <code>bandwidht</code>, <code>nonlinear</code>, <code>fsmoothing</code> and <code>tsmoothing</code> field, otherwise print an error message pointing to the first field that is not identical in all objects and return <code>Nothing</code>. This method applies to all <a href="../MainModule/#TFobjectsVector-1">TFobjectsVector</a> types, that is, <a href="../MainModule/#TFAnalyticSignalVector-1">TFAnalyticSignalVector</a>, <a href="../MainModule/#TFAmplitudeVector-1">TFAmplitudeVector</a> and <a href="../MainModule/#TFPhaseVector-1">TFPhaseVector</a>.</p><p><code>funcname</code> has the same meaning as in the previous method.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/27fb14de7d3fd949536bb04a5d414211c6878e30/src/tools.jl#L667-L680">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FourierAnalysis.isLinear" href="#FourierAnalysis.isLinear"><code>FourierAnalysis.isLinear</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function isLinear(𝒀::Union{FDobjectsVector, TFobjectsVector})</code></pre><p>Return true if all objects in <code>𝒀</code> are linear. By definition, <a href="../spectra/#Spectra-1">Spectra</a> and <a href="../timefrequency/#TFAmplitude-1">TFAmplitude</a> objects are linear. <a href="../crossspectra/#CrossSpectra-1">CrossSpectra</a>, <a href="../coherence/#Coherence-1">Coherence</a>, <a href="../timefrequency/#TFAnalyticSignal-1">TFAnalyticSignal</a> and <a href="../timefrequency/#TFPhase-1">TFPhase</a> objects may be linear or non-linear.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/27fb14de7d3fd949536bb04a5d414211c6878e30/src/tools.jl#L695-L703">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FourierAnalysis.isNonLinear" href="#FourierAnalysis.isNonLinear"><code>FourierAnalysis.isNonLinear</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function isNonLinear(𝒀::Union{FDobjectsVector, TFobjectsVector})</code></pre><p>Return true if all objects in <code>𝒀</code> are non-linear. By definition, <a href="../spectra/#Spectra-1">Spectra</a> and <a href="../timefrequency/#TFAmplitude-1">TFAmplitude</a> objects are linear. <a href="../crossspectra/#CrossSpectra-1">CrossSpectra</a>, <a href="../coherence/#Coherence-1">Coherence</a>, <a href="../timefrequency/#TFAnalyticSignal-1">TFAnalyticSignal</a> and <a href="../timefrequency/#TFPhase-1">TFPhase</a> objects may be linear or non-linear.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/27fb14de7d3fd949536bb04a5d414211c6878e30/src/tools.jl#L710-L718">source</a></section><footer><hr/><a class="previous" href="../plots/"><span class="direction">Previous</span><span class="title">Plots</span></a><a class="next" href="../fftw/"><span class="direction">Next</span><span class="title">FFTW planners</span></a></footer></article></body></html>
