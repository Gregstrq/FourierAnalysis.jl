<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Hilbert Transform ¬∑ FourierAnalysis</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../"><img class="logo" src="../assets/logo.png" alt="FourierAnalysis logo"/></a><h1>FourierAnalysis</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">FourierAnalysis Documentation</a></li><li><a class="toctext" href="../MainModule/">Main Module</a></li><li><a class="toctext" href="../tapers/">Tapering Window</a></li><li><span class="toctext">frequency domain</span><ul><li><a class="toctext" href="../spectra/">Spectral Estimations</a></li><li><a class="toctext" href="../crossspectra/">Cross-Spectral Matrices</a></li><li><a class="toctext" href="../coherence/">Coherence Matrices</a></li><li><a class="toctext" href="../goertzel/">Goertzel&#39;s Algorithms</a></li></ul></li><li><span class="toctext">time-frequency(TF) domain</span><ul><li><a class="toctext" href="../timefrequency/">TF Representations</a></li><li><a class="toctext" href="../timefrequencyuni/">TF Univariate Measures</a></li><li><a class="toctext" href="../timefrequencybi/">TF Bivariate Measures </a></li></ul></li><li><span class="toctext">utilities</span><ul><li><a class="toctext" href="../plots/">Plots</a></li><li><a class="toctext" href="../tools/">Tools</a></li><li><a class="toctext" href="../fftw/">FFTW planners</a></li><li><a class="toctext" href="../filters/">Filter Banks</a></li><li class="current"><a class="toctext" href>Hilbert Transform</a><ul class="internal"></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>utilities</li><li><a href>Hilbert Transform</a></li></ul><a class="edit-page" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/master/docs/src/hilbert.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Hilbert Transform</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="hilbert.jl-1" href="#hilbert.jl-1">hilbert.jl</a></h1><p>This unit implements analytic signal estimations using the <a href="../fftw/#fftw.jl-1">fftw.jl</a> unit for computing the <a href="https://en.wikipedia.org/wiki/Hilbert_transform">Hilbert transform</a></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FourierAnalysis.analyticsignal" href="#FourierAnalysis.analyticsignal"><code>FourierAnalysis.analyticsignal</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">   (1)
   function analyticsignal( X  :: Union{Vector{T}, Matrix{T}},
                            wl :: Int     = size(X, 1);
                     nonlinear :: Bool    =  false,
                     planner   :: Planner =  getplanner,
                     ‚è©       :: Bool    =  true) where T&lt;:Real

   (2)
   function analyticsignal( ùêó      :: Vector{Matrix{T}},
                            wl     :: Int;
                        nonlinear  ::  Bool      =  false,
                        planner    ::  Planner   =  getplanner,
                        ‚è©        ::  Bool      =  true) where T&lt;:Real</code></pre><p>(1)</p><p>Compute the analytic signal(AS) of vector <code>X</code> or of all column vectors of matrix <code>X</code> via the FFT and iFFT procedure, as explained in Marple(1999). If <code>wl</code>=size(X, 1) (default), use the standard method passing to the FFT and iFFT all samples in <code>X</code> altogether, whereas if <code>wl</code>&lt;size(X, 1) a Welch-like method is used (see below).</p><p>Return the analytic signal <code>ùëå</code>, a complex vector if <code>X</code> is a vector or a complex matrix holding in its columns the analytic signal of the columns of <code>X</code> if <code>X</code> is a matrix. <code>ùëå</code> has the same number of samples (rows) as <code>X</code>. Contrarely to what is done in the <a href="https://github.com/JuliaDSP/DSP.jl">DSP</a> package, the DC level of the signal is removed, therefore, if the input signal features a non-zero DC level, the real part of the AS will be equal to the input signal with the DC level removed. The imaginary part of <code>ùëå</code> is the Hilbert transform of such no-DC <code>X</code>.</p><p>The Welch-like AS allows an efficient estimation of the AS for vectors and matrices of any length, that is, even if they are very large; it proceeds computing the AS on 50% sliding overlapping windows and forming the AS by retaining the central half of each window. The number of points effectively used to obtain the final estimation is <span>$wl√∑2$</span> (integer division) if <code>wl</code> is even, <span>$wl√∑2+1$</span> otherwise. Using the central half of the AS computed at each window eliminates edge effects in the range <span>$wl√∑2:end-wl√∑2$</span>. Before running the procedure, <span>$wl√∑2$</span> zeros are padded at the beginning and at the end of <code>X</code> and trimmed on exiting the function, in order to reduce edge effects at the beginning and end of <code>X</code>. This procedure does not eliminate these edge effects completely, thus the first and last <span>$wl√∑2$</span> samples of the AS estimation should be discarded. In practice, one requires the AS of a larger data segment and trims at least <span>$wl√∑2$</span> samples at the beginning and end of the estimation. This is done automatically by the <a href="../timefrequency/#FourierAnalysis.TFanalyticsignal"><code>TFanalyticsignal</code></a> function.</p><div class="admonition note"><div class="admonition-title">Nota Bene</div><div class="admonition-text"><p>In order to avoid FFT computation of very long epochs, if <code>wl</code> &gt; 2^14, then <code>wl</code> is set to 2^10.</p><p>See <a href="../MainModule/#window-length-in-FFTW-1">window length in FFTW</a> for setting efficiently argument <code>wl</code>.</p><p>The input signal should be previously band-pass or high-pass filtered so as not to contain frequency components below the first discrete Fourier frequency obtained with windows of <code>wl</code> samples, that is, below sr/wl Hz, where sr is the sampling rate.</p></div></div><p><strong>Optional Keyword Arguments</strong>:</p><p><code>nonlinear</code>, if true, the analytic signal is normalized so that its amplitude is <span>$1.0$</span> at all points. This allow non-linear univariate and bivariate estimations (see <a href="../timefrequencyuni/#timefrequencyuni.jl-1">timefrequencyuni.jl</a> and <a href="../timefrequencybi/#timefrequencybi.jl-1">timefrequencybi.jl</a>).</p><p><code>planner</code> is an instance of the <a href="../fftw/#FourierAnalysis.Planner"><code>Planner</code></a> object, holding the forward and backward FFTW plans used to compute the FFTs and the iFFTs. By default the planner is computed, but it can be passed as an argumet here if it is pre-computed. This is interesting if the <code>analyticsignal</code> function is to be invoked repeatedly.</p><p>if <code>‚è©</code> is true, the method is run in multi-threaded mode across the series in <code>X</code> if the number of series is at least twice the number of threads Julia is instructed to use. See <a href="../MainModule/#Threads-1">Threads</a>.</p><p>(2)</p><p>Compute the analytic signal for all <span>$k$</span> multivariate data matrices given as a vector of matrices <code>ùêó</code>. Return a vector of matrices hodling the corresponding analytic signals as in method (1). The FFT and iFFT plans are computed only once. The <span>$k$</span> matrices in <code>ùêó</code> may have different number of columns (i.e., different number of series) and different number of rows (samples). However, the number of rows must be larger than <code>wl</code> for all of them. if <code>‚è©</code> is true, this method run in multi-threaded mode across the matrices in <code>ùêó</code> if the number of matrices is at least twice the number of threads Julia is instructed to use, otherwise it tries to run each analytic signal estimation in multi-threaded mode as per method (1). See <a href="../MainModule/#Threads-1">Threads</a>.</p><p>This function is called by the following functions operating on time-frequency reprsentations: <a href="../timefrequency/#FourierAnalysis.TFanalyticsignal"><code>TFanalyticsignal</code></a>, <a href="../timefrequency/#FourierAnalysis.TFamplitude"><code>TFamplitude</code></a>, <a href="../timefrequency/#FourierAnalysis.TFphase"><code>TFphase</code></a>, <a href="../timefrequencyuni/#FourierAnalysis.meanAmplitude"><code>meanAmplitude</code></a>, <a href="../timefrequencyuni/#FourierAnalysis.concentration"><code>concentration</code></a>, <a href="../timefrequencyuni/#FourierAnalysis.meanDirection"><code>meanDirection</code></a>, <a href="../timefrequencybi/#FourierAnalysis.comodulation"><code>comodulation</code></a>, <a href="../coherence/#FourierAnalysis.coherence"><code>coherence</code></a>.</p><p><strong>References</strong> Marple S.L. (1999) Computing the Discrete-Time Analytic Signal via FFT. IEEE Transactions on Signal Processing 47(9), 2600-3.</p><p><strong>Examples</strong>:</p><pre><code class="language-none">using FourierAnalysis, FFTW, LinearAlgebra, Statistics, Plots, DSP
t=128; lab=[&quot;x&quot;, &quot;real(y)&quot;, &quot;imag(y)&quot;]

# Analytic signal of one vector
x=sinusoidal(10, 2, 128, t, œÄ/2; DC=10) # cosine
y=analyticsignal(x)
# note that real(y) is x without the DC level, i.e., x=real(y)+DC
plot([x, real(y), imag(y)]; labels=lab)

# make a check
s=sinusoidal(10, 2, 128, t, 0) # sine
norm(s-imag(y)) # should be zero

# Analytic Signal by DSP.jl
y2=hilbert(x)
norm(s-imag(y2)) # should be zero
# DSP.jl does not remove the DC level
# thus x=real(y2) in this case
plot([x, real(y2), imag(y2)]; labels=lab)

# Analytic signal of multiple vectors
x=hcat(x, sinusoidal(10, 3, 128, t, œÄ/2; DC=10))
y=analyticsignal(x)

# welch-like analytic signal of one vector
# (note edge effects)
x=sinusoidal(10, 2, 128, t*4, œÄ/2; DC=0)
y=analyticsignal(x, t)
plot([x, real(y), imag(y)]; labels=lab)

# Welch-like analytic signal of multiple vectors
x=hcat(x, sinusoidal(10, 3, 128, t*4, œÄ/2; DC=0))
y=analyticsignal(x, t)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/94688f141e525f220d36ad108d5a99b4d06d3398/src/hilbert.jl#L12-L154">source</a></section><footer><hr/><a class="previous" href="../filters/"><span class="direction">Previous</span><span class="title">Filter Banks</span></a></footer></article></body></html>
